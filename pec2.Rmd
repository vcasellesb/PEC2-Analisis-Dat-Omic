---
title: "PEC 2"
author: "Vicent Caselles Ballester"
date: "`r Sys.Date()`"
output: bookdown::pdf_document2
bibliography: refs.bib
nocite: '@*'
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r, message=FALSE, echo=FALSE}
library(Biobase)
```

# Introducció

L'objectiu de la PAC 2 és la realització d'un anàlisi de dades de microarray d'un *dataset* obtingut del repositori públic d'NCBI **_Gene Expression Omnibus_** (**_GEO_**, [@Edgar2002]).

En aquesta PEC, intentaré demostrar que he anat assolint els coneixements que s'han exposat al contingut de l'assignatura Anàlisi de Dades Òmiques, concretament referent als mòduls 1 i 2 de l'assignatura. En el cas d'aquesta PEC, no realitzarem el pas de normalització de les dades ni de control de qualitat d'aquestes, tal i com vam fer a la prova anterior.

El exercici, doncs, consistirà en descarregar un conjunt de dades del repositori de GEO utilitzant el conjunt d'eines de `BioConductor`, el *fitteig* d'un model lineal amb `limma` que ens permeti realitzar contrasts entre els grups d'interès biològic, i l'obtenció a partir d'aquest model dels gens diferencialment expressats en un format **llista**.

A partir d'aquesta llista, podrem dur a terme el que es coneix com a l'annotació d'aquests gens, que ens permetrà extreure informació relativa als potencials processos biològics que poden veure afectats amb la presència o absència d'una determinada covariable. Això ho podem fer de diverses maneres, entre les quals destaquen el **_Over Representation Analysis_** (***ORA***) i el **_Gene Set Enrichment Analysis_** (**_GSEA_**).

```{r, eval=FALSE}
require(GEOquery)

gds <- getGEO('GDS2107')
remove(gds)
```

A continuació, descarrego les dades amb les que treballaré en aquesta PEC. Aquestes corresponen a la sèrie `GSE3311`, que formen part de l'estudi de @Kubisch2006. En aquest estudi, els autors van intentar mesurar els gens involucrats en la sensibilització del pàncrees que s'ha observat davant de consumició d'etanol a llarg termini.

```{r, cache=TRUE}
require(GEOquery)
gse <- getGEO('GSE3311')
```


# Materials i mètodes

## *Dataset*

El *dataset* escollit per a la realització d'aquesta PEC és el dataset amb *Accession ID* `GDS2107` o, per altra banda, a la sèrie amb *Accession ID* `GSE3311` (@Kubisch2006). 

Aquest estudi va separar dos grups de rates (*Rattus norvegicus*), a les quals se'ls hi va donar etanol durant 8 setmanes, moment en el qual van ser *eutanitzades* i el pàncrees extret per al seu anàlisi. Posteriorment, es va homogeneïtzar el teixit pàncreatic de 3/4 rates per grup experimental, i aquest homogeneïtzat és el que va ser analitzat en el *microarray*.

És a dir, entenc que les 6 mostres són rèpliques tècniques provenent 3 del homogeneïtzat del grup control i 3 del homogeneïtzat del grup tractat amb etanol.

Utilitzant el *slot* de l'`ExpressionSet` anomenat `phenoData`, podem extreure informació molt valuosa referent al *dataset* `GDS2107`. Per exemple, podem esbrinar el número de canals (i també si totes les mostres tenien el mateix número de canals).

```{r}
unique(pData(gse[[1]])$channel_count)
```

Veiem que tots els canals tenen només un canal.

```{r wistar-rat}
unique(pData(gse[[1]])$characteristics_ch1)
```

Les mostres provenen totes de rates de tipus Wistar, i també interessant, totes eren mascles de sexe (no tenim sexe com a covariable).

```{r}
knitr::kable(pData(gse[[1]])[, c(1,31)])
```

A més podem veure el tractament i rèplica al que pertany cada *sample*. Amb aquesta informació, canvio el nom de les columnes de l'`ExpressionSet` per tal de que siguin més informatives.

```{r}
colnames(gse[[1]]) <- paste(c(rep("Ctrl", 3), rep('Eth', 3)), c("01", "02", "03"),
                            sep='')
```


## Eines de `BioConductor` [@huber2015]

### `GEOquery` [@geoquery2007]

Com he mencionat abans, GEOquery és un paquet que permet la interacció amb el repositori de dades d'NCBI **_Gene Expression Omnibus_**. D'aquesta manera, permet descarregar fàcilment conjunts  de dades directament des de R, obtenint-les en formats compatibles amb els altres paquets de `BioConductor`.

### `limma` [@limma2015]

Per a dur a terme els anàlisis estadístics de les dades del *microarray*, i.e. l'ànalisi de gens diferencialment expressats entre els grups experimentals, utilitzarem el paquet `limma`, que permet ajustar models lineals en gran conjunts de dades com els microarrays. 

### `arrayQualityMetrics` [@aQM2009]

El paquet `arrayQualityMetrics` permet realitzar un control de qualitat de dades de *microarray* de manera fàcil, mitjançant l'ús de bàsicament una única funció. Guarda els resultats (imatges i un fitxer `html` que facilita la comprensió del QC amb interpretacions dels gràfics que es generen) a un directori que l'usuari especifica.

### `genefilter` [@genefilter2023]

Per a realitzar el filtratge preliminar de gens, utilitzarem el paquet `genefilter`. Aquest paquet permet utilitzar diferents criteris per a descartar gens que potencialment no ens interessen. Aquests criteris solen estar relacionats a la variabilitat que mostren els gens, si tenen una annotació a ENTREZ, o altres.

Aquest tipus de filtratge es sol dir no específic. Es defineix com a filtratge específic aquell que està relacionat amb els grups experimentals (i.e. que no està diferencialment expressat (DE) en els dos -- o més -- grups experimentals). En canvi l'inespecífic és el que no està relacionat amb aquests criteris (d'acord a la `vignette` del paquet).

# Resultats i discussió

## Control de qualitat

Primer de tot, recullo les dades d'expressió de manera que sigui còmode treballar amb elles.

```{r}
eset_eth <- gse[[1]]
class(eset_eth)
```

Veiem que aquest objecte és un `ExpressionSet` com déu mana.

Per a dur a terme el control de qualitat, faig servir la funció `arrayQualityMetrics` per a fer el control de qualitat de les dades, però no mostro el codi. He seleccionat quatre gràfics que contenen informació rellevant referent al control de qualitat.

```{r, warning=FALSE, cache=TRUE, message=FALSE}
require(arrayQualityMetrics)
arrayQualityMetrics(eset_eth, outdir='report_exprsdata', force=T)
```

```{r arrayQM, echo=FALSE, fig.show="hold", out.weight="49%", out.height="20%", fig.cap="Control de qualitat mitjançant ArrayQualityMetrics", fig.align='center'}
knitr::include_graphics(c('report_exprsdata/hm.png', 'report_exprsdata/msd.png', 
                          'report_exprsdata/dens.svg', 'report_exprsdata/box.png'))
```

Com podem veure a la figura \@ref(fig:arrayQM), els boxplots clarament demostren que les dades estan normalitzades. També he realitzat un *boxplot* "manualment" (fig. \@ref(fig:boxplot-vicent)), però com veieu em surten molts *outliers* (cercles). No sé fins a quin punt això pot resultar preocupant, però ja que totes les mostres mostren un comportament similar, entenc que aquest problema no és sistèmic. Sembla sorprenent que això només em passi utilitzant la funció `boxplot`, mentre que utilitzant `arrayQualityMetrics` això no s'observi.

```{r boxplot-vicent, fig.cap="Boxplot de les intensitats de les diferents mostres", out.width='60%', fig.align="center"}
boxplot(exprs(eset_eth), which='all', cex.axis=0.6, 
        names = colnames(eset_eth), las=1, horizontal=TRUE)
```

Cal destacar també que, al gràfic de dalt a la esquerra de la figura \@ref(fig:arrayQM), es pot observar que la mostra 4, que correspon a la primera rèplica del grup etanol, presenta una suma de les distàncies ($S_i = \sum_j d_{ij}$, on $dij$ és la distància $L_1$ entre les mostres $i$ i $j$) excepcionalment gran.

Utilitzant el codi del professor de l'assignatura (concretament, el de https://github.com/ASPteaching/Analisis_de_datos_omicos-Ejemplo_0-Microarrays), realitzaré un gràfic de les dues components principals.

```{r echo=FALSE}
plotPCA <- function ( X, labels=NULL, colors=NULL, dataDesc="", scale=FALSE)
{
  pcX<-prcomp(t(X), scale=scale) # o prcomp(t(X))
  loads<- round(pcX$sdev^2/sum(pcX$sdev^2)*100,1)
  xlab<-c(paste("PC1",loads[1],"%"))
  ylab<-c(paste("PC2",loads[2],"%"))
  if (is.null(colors)) colors=1
  plot(pcX$x[,1:2],xlab=xlab,ylab=ylab, col=colors, 
       xlim=c(min(pcX$x[,1])-10000, max(pcX$x[,1])+10000),
       ylim=c(min(pcX$x[,2])-10000, max(pcX$x[,2])+10000),
       )
  text(pcX$x[,1],pcX$x[,2], labels, pos=3, cex=0.8)
  titulo <- ifelse(dataDesc=="", "PCA Plot", 
                   dataDesc)
  title(titulo, cex=0.8)
}
```

```{r pca-graph, out.width='60%', fig.align='center', fig.cap="Resultat de graficar les dues principals components de les dades del 'nostre' experiment"}
plotPCA(exprs(eset_eth), labels=colnames(eset_eth))
```

Aquest ens permet comprovar si les mostres (o l'expressió que podem observar en aquestes) es comporta com esperaríem, mitjançant un potencial clustering d'acord a les dues components principals (les que expliquen més variabilitat del conjunt de dades). Com podem observar, les mostres es disposen segons el seu grup o tractament principalment a través de la component 1, que explica la majoria de la variança de les dades ($61.7\%$). Per altra banda, veiem que les dades control es troben molt més properes entre elles, mentre que les dades del grup etanol es separen principalment al llarg de la PC2.

## Filtrat de gens no específic

Per a realitzar el filtratge de gens no específic, utilitzaré la funció `nsFilter` de `genefilter`. Dintre dels criteris que podem triar, utilitzaré aquells que he vist en els materials de l'assignatura. Quasi sempre es filtren aquells gens que presenten una variabilitat baixa (mesurada amb el `IQR`, o *Inter Quantile Range*), i també aquells gens que no estan annotats a ENTREZ.

```{r, message=FALSE}
require(genefilter)
annotation(eset_eth) <- 'rae230a.db'
if (!require(annotation(eset_eth), character.only = T)) 
  BiocManager::install(annotation(eset_eth))
filtered_eset = nsFilter(eset_eth, var.func=IQR, var.cutoff=0.75, var.filter=TRUE, 
                         require.entrez=TRUE, filterByQuantile=TRUE)
```

Com veieu, he marcat com a annotació per al filtratge el paquet `rae230a.db`, que és el tipus de *chip* que s'ha utilitzat per a les mostres d'aquest experiment, segons la pàgina web de GEO. Com veieu, filtrem els gens (o *probes*, *features*) que presenten un IQR (el quantil 0.75 menys el 0.25) menor al IQR que deixa un 75% de IQRs per sota d'aquest. Així doncs, estem descartant un 75% de les dades amb menor variabilitat (definida per IQR).

```{r}
filtered_eset$filter.log
```

Com podem veure, el número de *probes* filtrades per "LowVar" és 8070. Això inicialment m'ha fet pensar que algo havia fet malament, ja que `r "8070/nrow(eset_eth) == "`  `r round(8070/nrow(eset_eth), 2)`. Però, llegint més atentament la documentació de `nsFilter`, trobem que el filtratge de gens degut a la variança es duu a terme en últim lloc, així que el càlcul hauria de ser el següent: `r "8070/(nrow(eset_eth) - filtered_eset$filter.log$(numDupsRemoved, numRemoved.ENTREZID, feature.exclude))"`. És a dir, hauríem de fer la divisió amb el denominador resultant de fer el filtratge d'acord a tots els altres criteris excloent la variança. Això dóna: `r round(filtered_eset$filter.log$numLowVar / (nrow(eset_eth) - (filtered_eset$filter.log$numRemoved.ENTREZID + filtered_eset$filter.log$feature.exclude + filtered_eset$filter.log$numDupsRemoved)), 2)`.

Així doncs, s'ha fet el filtratge de manera satisfactòria. Veiem que hem perdut un total de `r sum(filtered_eset$filtered.log)`. Concretament, degut al criteri de variança baixa s'han filtrat `r filtered_eset$filter.log$numLowVar`; pel criteri de filtratge de sondes conegudes com a sondes de control de qualitat d'Affymetrix s'han exclòs `r filtered_eset$filter.log$feature.exclude`; pel criteri d'exclusió de sondes no anotades per ENTREZ s'han deixat enrere `r filtered_eset$filter.log$numRemoved.ENTREZID`; i, finalment, en quant a sondes duplicades s'han filtrat `r filtered_eset$filter.log$numDupsRemoved` sondes.

## *Fitteig* del model lineal

Ara, procedeixo a generar l'objecte corresponent al model lineal que utilitzaré per a trobar els gens diferencialment expressats. Per a això utilitzem el paquet popular `limma`. Creo una matriu de disseny molt facileta, amb dos columnes (una per a cada coeficient corresponent als nivells del factor "tractament" (Control, i tractat amb etanol)), i el mateix número de files com mostres hi ha a l'`ExpressionSet`.
```{r, message=FALSE}
require(stringr); require(limma)
myeset <- filtered_eset$eset
groups <- str_replace_all(colnames(myeset), "[:digit:]", "")

design <- model.matrix(~0 + factor(c(1,1,1,2,2,2)))
colnames(design) <- unique(groups)
rownames(design) <- colnames(exprs(myeset))
show(design)
```
Un cop preparada la matriu de disseny, podem realitzar el *fit* del model, amb la funció `lmFit`.

```{r, message=FALSE}
require(limma)
fit <- lmFit(myeset, design)
```

Ara, ja que ens interessa comprovar en quins gens hi ha diferències significatives entre els dos grups experimentals, crearem una matriu de contrast que faci aquesta comparació. Com que només tenim un factor amb dos nivells, el número de contrasts només serà 1.

```{r}
contrast.matrix <- makeContrasts(Eth - Ctrl, levels=design)
show(contrast.matrix)
```
Un cop ho tenim tot preparat, podem procedir a realitzar els contrasts per al model que hem ajustat prèviament. Aplicarem la funció `eBayes`, que permet obtenir *t-stats*, *F-stats* i *log-odds* "moderats" mitjançant tècniques d'estadística Bayesian, tenint en compte la variança dels gens a tot el microarray. 

```{r}
require(limma)
fit2 <- contrasts.fit(fit, contrast.matrix)
fit2 <- eBayes(fit2)
```

Un cop fet això, podem obtenir la taula amb els gens ordenats segons la seva expressió diferencial, donada pel *B-statistic* o el *p-value*. Com veiem, el *gene symbol* del gen "més diferencialment expressat" correspon a Nudt4.

```{r}
topTabCtrlvsEth <- topTable(fit2, number=nrow(fit2), coef="Eth - Ctrl", adjust="fdr")
head(topTabCtrlvsEth[,c("Gene.Symbol", 'logFC', 't', 'B', 'adj.P.Val')])
```

Podem fer una primera visualització dels resultats amb la confecció d'un *volcano plot*.

```{r volcanoplot}
volcanoplot(fit2, highlight=10, names=fit2$genes$`Gene Symbol`, 
            main="Volcano plot of DE genes from our analysis")
```

Com és obvi a la figura \@ref(fig:volcanoplot), hi ha un gen que despunta clarament en quant al seu Log2 FC, amb un valor negatiu $< -60000$. Podem trobar més informació sobre aquest gen de la manera següent.

```{r}
which.max(abs(topTabCtrlvsEth$logFC))
topTabCtrlvsEth[185, c('Gene.Symbol', 'logFC', 't', 'adj.P.Val', 'B')]
```
Podem veure que aquest gen correspon a la sonda `r rownames(topTabCtrlvsEth[185,])`, amb el *Gene Symbol* Reg1a, i que no assoleix un p-valor significatiu.

Si el treiem del *volcano plot*:

```{r}
ix = which(fit2$genes$ID=="1368629_at")
fit2withoutoutlier <- fit2[-ix,]
volcanoplot(fit2withoutoutlier, highlight=10, names=fit2withoutoutlier$genes$`Gene Symbol`, 
            main="Volcano plot of DE genes from our analysis")
```

D'aquesta manera podem veure els 10 gens més diferencialment expressats. Només per curiositat, vull veure el SE del gen que té el |logFC| tan gran, per esbrinar el motiu de que no aparegui amb un p-valor significatiu.

```{r}
fit2$s2.post['1368629_at']
which.max(fit2$s2.post)
```
Com veiem, té un valor del error estàndard corresponent a la distribució posterior per a la variança bastant gran (el major de tot el *fit*).

Després d'obtenir aquesta taula, podem obtenir un vector o llista amb els gens expressats diferencialment mitjançant la funció `decideTests` del paquet `limma`.

```{r}
results<-decideTests(fit2, adjust.method="fdr", p.value=0.05, lfc=3)
summary(results)
```

Pateixo amb això.

```{r}
ex <- exprs(eset_eth)
# log2 transform
qx <- as.numeric(quantile(ex, c(0., 0.25, 0.5, 0.75, 0.99, 1.0), na.rm=T))
LogC <- (qx[5] > 100) ||
          (qx[6]-qx[1] > 50 && qx[2] > 0)
if (LogC) { ex[which(ex <= 0)] <- NaN
  ex <- log2(ex) }
```


# Referències

